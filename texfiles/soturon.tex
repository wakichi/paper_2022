\documentclass[11pt,a4paper,dvipdfmx,titlepage,uplatex]{jsarticle}

\usepackage{ascmac}
\usepackage{url}
\usepackage{amssymb}
\usepackage{comment}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{optidef}
\usepackage[dvipdfmx]{hyperref}
\usepackage{pxjahyper}
\setcounter{tocdepth}{3}%目次をサブセクションまで表示
\usepackage{multirow}
% \usepackage{caption}


\newtheoremstyle{mystyle}%   % スタイル名
{}%b                     % 上部スペース
{}%                      % 下部スペース
{\normalfont}%              % 本文フォント
{}%                      % 1行目のインデント量
{\bfseries}%             % 見出しフォント
{.}%                     % 見出し後の句読点
{ }%                     % 見出し後のスペース
{\thmname{#1}\thmnumber{ #2}\thmnote{ (#3)}}

\theoremstyle{mystyle}
\newtheorem{mythm}{定理}[section]

\makeatletter
\renewenvironment{proof}[1][\proofname]{\par
	\pushQED{\qed}%
	\normalfont \topsep6\p@\@plus6\p@\relax
	\trivlist
	\item\relax
	{\bfseries
		#1\@addpunct{.}}\hspace\labelsep\ignorespaces
}{%
	\popQED\endtrivlist\@endpefalse
}
\makeatother

\usepackage{algorithm,algorithmic}

\usepackage{pdfpages}
\usepackage{graphicx}

\usepackage{mathtools}
\mathtoolsset{showonlyrefs=true}

\usepackage{enumerate}
\usepackage{tabularx}
\newcolumntype{Y}{&gt;{\centering\arraybackslash}X} %中央揃え

\usepackage{booktabs}
\usepackage{siunitx}
\usepackage{dcolumn}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{colortbl}
\usepackage{arydshln}

\usepackage{afterpage}%
\usepackage{float}
\usepackage{here}

\usepackage{environ}
\NewEnviron{resizealign}{\sbox0{\let\notag=\relax
		$\begin{matrix}\displaystyle\BODY\end{matrix}$}%
	\sbox1{$(\theequation)$}%
	\sbox2{\parbox{\dimexpr \wd0 + 2\wd1}%
		{\begin{align}\BODY\end{align}}}% for testing
	\noindent\resizebox{\textwidth}{!}{\usebox2}%
}

\usepackage{listings}
\renewcommand{\lstlistingname}{List}
% basicstyle=\ttfamily\small,numberstyle=\ttfamily\footnotesize, numbers=left, frame=single
\lstset{
	% language=c,
	breaklines = true,
	basicstyle=\ttfamily\small,
	commentstyle=\textit,
	% classoffset=1,
	keywordstyle=\bfseries,
	frame=single,
	framesep=5pt,
	showstringspaces=false,
	numbers=left,
	stepnumber=1,
	upquote = true,
	numberstyle=\ttfamily\footnotesize
	% tabsize=2
}

\usepackage{color}
\newcommand{\blue}[1]{\begin{color}{blue}#1\end{color}}
\newcommand{\red}[1]{\begin{color}{red}#1\end{color}}
\newcommand{\green}[1]{\begin{color}{green}#1\end{color}}
\newcommand{\memoblue}[1]{\ifmymemo \begin{color}{memoblue}#1\end{color}\fi}
\newcommand{\modify}[2]{\begin{color}{red}\underline{#1}{#2}\end{color}}

\newcommand{\st}{\textrm{s.t.}}
\newcommand{\Tr}{\mathbf{T}}
\newcommand{\0}{\mathbf{0}}
\newcommand{\diag}{\mathrm{diag}}
\newcommand{\argmin}{\mathrm{argmin}}
\newcommand{\argmax}{\mathrm{argmax}}
\newcommand{\ST}{\mathrm{ST}}
\newcommand{\prox}{\mathrm{prox}}

\newtheorem*{theorem*}{定理}
\newtheorem{theorem}{定理}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem*{proposition*}{Proposition}
\newtheorem{remark}[theorem]{注}
\newtheorem{example}[theorem]{例}
\newtheorem*{remark*}{注}
\newtheorem{lemma}[theorem]{補題}
\newtheorem{assumption}[theorem]{仮定}
\newtheorem{corollary}[theorem]{系}
\newtheorem{definition}[theorem]{定義}
\newtheorem*{definition*}{定義}

\def\br{\hfill\break}
\def\bold#1{\mbox{\boldmath $#1$}}

%
%file name = bflatex.tex
%
\def\0{\mbox{\bf 0}}
\def\1{\mbox{\bf 1}}
\def\2{\mbox{\bf 2}}
\def\3{\mbox{\bf 3}}
\def\4{\mbox{\bf 4}}
\def\5{\mbox{\bf 5}}
\def\6{\mbox{\bf 6}}
\def\7{\mbox{\bf 7}}
\def\8{\mbox{\bf 8}}
\def\9{\mbox{\bf 9}}
\def\a{\mbox{\boldmath $a$}}
\def\b{\mbox{\boldmath $b$}}
% curled charcter can be used by \chige{a}
\let\chige\c

\def\c{\mbox{\boldmath $c$}}

% details are written in  /usr/share/texmf/tex/plain/base/plain.tex
% \newdimen\zhige \zhige=0pt
% \def\chige#1{{\setbox\zhige\hbox{#1}\ifdim\ht\zhige=1ex\accent24 #1%
		%  \else\ooalign{\unhbox\zhige\crcr\hidewidth\char24\hidewidth}\fi}}

\def\cc{\mbox{\boldmath $c$}}
\def\d{\mbox{\boldmath $d$}}
\def\e{\mbox{\boldmath $e$}}
\def\f{\mbox{\boldmath $f$}}
\def\g{\mbox{\boldmath $g$}}
\def\h{\mbox{\boldmath $h$}}
\def\i{\mbox{\boldmath $i$}}
\def\j{\mbox{\boldmath $j$}}
\def\k{\mbox{\boldmath $k$}}
\def\l{\mbox{\boldmath $l$}}
\def\m{\mbox{\boldmath $m$}}
\def\n{\mbox{\boldmath $n$}}
\def\o{\mbox{\boldmath $o$}}
\def\p{\mbox{\boldmath $p$}}
\def\q{\mbox{\boldmath $q$}}
\def\r{\mbox{\boldmath $r$}}
\def\s{\mbox{\boldmath $s$}}
\def\t{\mbox{\boldmath $t$}}
\def\u{\mbox{\boldmath $u$}}
\def\v{\mbox{\boldmath $v$}}
\def\w{\mbox{\boldmath $w$}}
\def\x{\mbox{\boldmath $x$}}
\def\y{\mbox{\boldmath $y$}}
\def\z{\mbox{\boldmath $z$}}
\def\A{\mbox{\boldmath $A$}}
\def\B{\mbox{\boldmath $B$}}
\def\C{\mbox{\boldmath $C$}}
\def\D{\mbox{\boldmath $D$}}
\def\E{\mbox{\boldmath $E$}}
\def\F{\mbox{\boldmath $F$}}
\def\G{\mbox{\boldmath $G$}}
\def\H{\mbox{\boldmath $H$}}
\def\I{\mbox{\boldmath $I$}}
\def\J{\mbox{\boldmath $J$}}
\def\K{\mbox{\boldmath $K$}}
\def\L{\mbox{\boldmath $L$}}
\def\M{\mbox{\boldmath $M$}}
\def\N{\mbox{\boldmath $N$}}
\def\O{\mbox{\boldmath $O$}}
\def\P{\mbox{\boldmath $P$}}
\def\Q{\mbox{\boldmath $Q$}}
\def\R{\mbox{\boldmath $R$}}
\def\S{\mbox{\boldmath $S$}}
\def\T{\mbox{\boldmath $T$}}
\def\U{\mbox{\boldmath $U$}}
\def\V{\mbox{\boldmath $V$}}
\def\W{\mbox{\boldmath $W$}}
\def\X{\mbox{\boldmath $X$}}
\def\Y{\mbox{\boldmath $Y$}}
\def\Z{\mbox{\boldmath $Z$}}
\def\AC{\mbox{$\cal A$}}
\def\BC{\mbox{$\cal B$}}
\def\CC{\mbox{$\cal C$}}
\def\DC{\mbox{$\cal D$}}
\def\EC{\mbox{$\cal E$}}
\def\FC{\mbox{$\cal F$}}
\def\GC{\mbox{$\cal G$}}
\def\HC{\mbox{$\cal H$}}
\def\IC{\mbox{$\cal I$}}
\def\JC{\mbox{$\cal J$}}
\def\KC{\mbox{$\cal K$}}
\def\LC{\mbox{$\cal L$}}
\def\MC{\mbox{$\cal M$}}
\def\NC{\mbox{$\cal N$}}
\def\OC{\mbox{$\cal O$}}
\def\PC{\mbox{$\cal P$}}
\def\QC{\mbox{$\cal Q$}}
\def\RC{\mbox{$\cal R$}}
\def\SC{\mbox{$\cal S$}}
\def\TC{\mbox{$\cal T$}}
\def\UC{\mbox{$\cal U$}}
\def\VC{\mbox{$\cal V$}}
\def\WC{\mbox{$\cal W$}}
\def\XC{\mbox{$\cal X$}}
\def\YC{\mbox{$\cal Y$}}
\def\ZC{\mbox{$\cal Z$}}

\def\Real{\mbox{$\mathbb{R}$}}
\def\Complex{\mbox{$\mathbb{C}$}}
\def\SMAT{\mbox{$\mathbb{S}$}}
\def\Integer{\mbox{$\mathbb{Z}$}}
\def\Natural{\mbox{$\mathbb{N}$}}
\def\ascript{\mbox{\scriptsize $\a$}}
\def\blambda{\mbox{\boldmath $\lambda$}}
\def\etab{\mbox{\boldmath $\eta$}}
\def\balpha{\mbox{\boldmath $\alpha$}}
\def\bbeta{\mbox{\boldmath $\beta$}}
\def\bzeta{\mbox{\boldmath $\zeta$}}
\def\bmu{\mbox{\boldmath $\mu$}}

\newcommand{\oz}{\overline{z}}
\newcommand{\oc}{\overline{\c}}
\newcommand{\ob}{\overline{\b}}
\newcommand{\cO}{\mathcal{O}}
\title{{\large 令和5年度　学士論文}\\ \vskip\baselineskip
	時間制約付きcarrier vehicle routing問題に対する\\二次錐計画問題を用いた解法}
\author{東京工業大学　情報理工学院　数理・計算科学系\\
	学籍番号　19B31048\\
	脇田康平\\
	指導教員 山下 真 教授\\
}
\date{2023年2月27日}
\begin{document}
	
	\maketitle
	
	\tableofcontents
	\clearpage
	
	\section{はじめに}\label{sec:introduction}
	%1. ドローンに関する一般的なこと
	無人航空機、いわゆるドローンは空中を飛行し、荷物を積載できるといった特徴をもつ。
	そのため、現在では軍事や農業、測量などといった幅広い分野で利用されている。
	また、人手不足や交通渋滞で困難に直面している物流業界においてもその利用が期待されている。
	一方、ドローンは空中を飛行するという特性上、大容量のバッテリーを積むことができず、数時間程度しか飛行できないデメリットも持っている。
	そこで、特に物流業界においては倉庫と目的地を直接ドローンをもちいて荷物を輸送せず、トラックなどの輸送機器にドローンと荷物を載せ、目的地付近でドローンを飛ばして輸送することが多い。
	この方法では、ドローンを飛ばしていない時間に充電をすることも可能である。
	ドローンを配送に用いる場合、通常の一種類の輸送機器のみで行う配送計画問題と異なり、ドローンの離着陸地点を決定する必要がある。
	
	%2. ドローンを用いた配送計画の一般的なこと（参考文献 5 個以上）
	%0 離散
	ドローンを用いた配送計画問題は、市街地などの駐車スペースが限られるような現実の問題に応用しやすい利点もあり、ドローンの離着陸可能座標が予め与えられた離散な問題の場合でも広く研究されている。\cite{luo2017two}
	%1. 問題の例,シチュエーション
	しかし、本論文であつかう配送計画問題は、ユークリッド平面上の任意の座標で離着陸が可能であるような設定である。この問題では、離散な場合と異なり、海上での船とヘリコプターなどの応用例が考えられる。\cite{poikonen2020mothership}
	CVTSPは混合整数二次錐計画問題として定式化できることが示されており\cite{gambella2018vehicle}、branch-and-cutアルゴリズムなどで厳密解を求めることができる。\cite{tamke2021branch}
	一方CVTSPはNP困難なクラスに属しているため、一般に解くのが難しく、ヒューリスティクスを用いて近似解を求める手法も研究されている。Larasatiらの研究では焼きなまし法をベースにした手法を用いている。\cite{larasati2022integrated}
	またこの問題は荷物に応じてバッテリー消費量や速度を変化させたり、キャパシティ以内のいくつかの荷物を輸送する問題などアレンジの幅がある。
	Klaucoらの研究では、droneが飛行できる間であれば二箇所以上の目的地を訪れることができる問題を扱っている。\cite{klauvco2014mixed}
	
	%3. ドローンを用いた配送計画のうち、SOCP を用いた先行研究の概略（参考文献３個以上）2.ここは、Klauco のようなドローンと船のルートの計算結果の図を用いて説明すると分かりやすくなります。
	%1. garone
	%2. gambella
	%3. 
	CVTSPを定式化する研究についてより詳しく述べる。Garoneらの研究において、事前に目的地をたどる順番を与えられたときのドローンの離着陸地点を決める問題の定式化が与えられた。\cite{garone2010planning}
	その後、目的地も離着陸点の決定と同時に求められるモデルがGambellaらの研究によって示された。\cite{gambella2018exact}
	ここで示されたモデルを用いてCVTSPを実際に解いてみると、図\ref{fig:example_CPLEX}のような経路となる。
	\begin{figure}[htbp]
		\centering
		\includegraphics[scale = 0.7]{resources/cplex_sample.png}
		\caption{ソルバーでCVTSPを説いた例}
		\begin{minipage}[c]{0.7\hsize}
			$p_s$からスタートし、すべての目的地$q$をたどったあと$p_f$に至る最短の経路赤色の丸と四角はそれぞれドローンの離着陸地点を表している。
		\end{minipage}
		\label{fig:example_CPLEX}
	\end{figure}
	
	%4. 今までの先行研究で足りていないことは何か
	
	%5.「本論文では、」で始める段落を作って、本論文で何をやったのかの概略を１ or 2 段落程度でまとめる
	本論文では、目的地のそれぞれが配達の時間制限を持つCVTSPを定義し、焼きなまし法と呼ばれるヒューリスティック手法を用いて高速でより精密な近似解を求めることを目標とする。
	提案手法では、この問題を目的地をたどる順番を求める問題と、ドローンの離着陸地点を求める問題の２つに分割し、前者は離散最適化問題であるためヒューリスティック手法を用いて決定し、後者は連続最適化問題であり、二次錐計画問題として定式化した後CPLEXという既存ソルバーを用いて決定した。
	
	%6. 数値実験でどんなことをやったか、をまとめて、実際にどういった結果が得られたか（計算時間が 5% 削減できたとか。）
	実験では、対象とする問題を直接混合整数二次錐計画問題として定式化しCPLEXで求めた手法と提案手法との比較を行った。
	その結果、精度は目的地数が17以下の場合の誤差が10\%程度であるが、実行時間は大幅に短くなった。
	また、提案手法のパラメータの一つであるイテレータ数を変化させ、結果を観察した。ここからイテレータ数を大きくすればおおよそ結果が改善することがわかった。
	
	本論文の構成は次のようになっている。
	第二章で本論文で用いる焼きなまし法とMISOCPの概略と２つの先行研究について説明し、第三章では時間制約付きcarrier-vehicle Traveling Salesman (CVTSPWT)問題を定義してMICOSPとして定式化する。
	その後、第四章ではCVTSPWTへの手法を提案し、第五章では生成したCVTSPWT問題のインスタンスを用いて数値実験を行う。
	最後に第六章で本論文のまとめと今後の課題について述べる。
	
	\subsection{記法}\label{sec:notation}
	
	
	この論文で扱う記法を述べる。
	\begin{itemize}
		\item $\|\cdot\|$はユークリッドノルムとする。
		\item 上付き添え字 $T$ は行列やベクトルの転置を示す。
		\item $\x^T \y$はベクトル$\x,\y \in \Real^n$の内積$\sum_{i=1}^n x_i y_i$である。
		\item ２つのベクトル$\x , \y \in \Real^n$に対して、$\x \circ \y$を次のように定義する。
	\end{itemize}
	
	\clearpage
	\section{先行研究}\label{sec:previousResarch}
	この章では時間制約なしのCVTSPを扱っている二つの先行研究を紹介する。前者はCVTSPの定式化について、後者はCVTSPを解く手法について説明をする。また、焼きなまし法と混合整数二次錐計画問題についても事前知識として扱う。
	\subsection{混合整数二次錐計画問題}\label{sec:MISOCP}
	二次錐計画問題はノルムを扱えるため汎用性が高いだけでなく、内点法を用いて効率的に求解をすることができるという特徴がある。\cite{potra2000interior}本章の定義は\cite{boyd2004convex}を参考にしている。
	
	$m_i$次元の二次錐$\mathcal{K}_i$を
	\begin{equation}
		\mathcal{K}_i  = 
		\begin{cases}
			(z_0, \bar{z}) \in \Real \times \Real^{m_{i-1}}:z_0\geq ||\bar{z}||&(m_i > 0)\\
			z \in \Real:z\geq 0&(m_i = 0)
		\end{cases}
	\end{equation}
	と定義する。
	
	$\mathcal{K}$を$\mathcal{K}_1$から$\mathcal{K}_l$の直積とすると、
	二次錐計画問題(SOCP)の一般的な形は
	\begin{align}
		\begin{array}{rcl}
			\min & : & \f ^T\x \\
			\text{subject to} & : &\x \in \mathcal{K} \\
			& & \F\x=\g\\
		\end{array}
	\end{align}
	で定義できる。
	ここで、$f \in \Real^n , \A_i \in \Real^{n_i\times n}, \b_i \in \Real^{n_i}, \c \in \Real^n, \d_i \in \Real, \F \in \Real^{p\times n}, \g \in \Real^p$は定数で$\x \in \Real^n$は目的変数である。
	
	SOCPをノルムを用いて変形すると以下の数式のように表せる。
	
	\begin{align}
		\begin{array}{rcl}
			\min & : & \f ^T\x \\
			\text{subject to} & : &||\A_i x +\b_i||_2 \leq \c_i^T\x+\d_i, i = 1,\dots, m \\
			& & \F\x=\g\\
		\end{array}
	\end{align}
	
	
	次に混合整数二次錐計画問題(MISOCP)の定義について述べる。
	% 変形した最適化問題の定義
	\begin{align}
		\begin{array}{rcl}
			\min & : & \f ^T\x \\
			\text{subject to} & : &||\A_i x +\b_i||_2 \leq \c_i^T\x+\d_i, i = 1,\dots, m \\
			& & \F\x=\g\\
			& & \x_i \in \mathbb{Z}, (i=1,\dots, n)
		\end{array}
	\end{align}
	
	
	混合整数二次錐計画問題は決定変数が離散であるため組合せ最適化のアルゴリズムを用いて最適値を求める必要がある。branch-and-cut\cite{drewes2009mixed}が代表的な手法である。
	\subsection{Gambellaらの手法}\label{sec:gambella}
	
	Gambellaらの用いたCVTSPに対するMISOCPでの定式化について解説する。このモデルは事前に目的地を辿る順番が与えられている状況でvehicleの離着陸地点を決める問題であるcarrier-vehicle problem(CVP)を解くためにGarone et al(2010)\cite{garone2010planning}において定義されたモデルをCVTSPに拡張したものである。このモデルの特徴は、目的地を辿る順番を決定変数として組み込んでいるため、vehicleの離着陸地点の決定問題と同時にそれらを求めることができる点にある。
	
	このモデルは、depotから出発しすべての目的地を辿り再びdepotに戻る時間の総和である線形な目的関数と、離着陸地点と目的地の距離と移動時間と速さの関係であるノルムを含んだ不等式、変数に対する下限と上限を定めた線形な制約式からなっているためMISOCPである。
	
	\subsection{焼きなまし法の説明}\label{sec:SA}
	%欲しい参考文献(焼きなましについて詳しい論文、TSPやその他問題を解く論文、Branch-and-cutと比較した論文)
	%1. 焼きなまし法とは何か. どう言う問題に使えるのか、他の手法と比較して何が違うのか。タブーやGA, 山登りと比べる？ ok
	焼きなまし法(Simulated Annealing)とは、最適化問題に対し現実的な時間で近似解を求めるための確率的メタヒューリスティクスの一種である。\cite{kirkpatrick1983optimization} この手法は巡回セールスマン問題\cite{geng2011solving}や充足可能性問題\cite{spears1993simulated}といった探索空間が離散である問題に適用することができる。目的関数値が良くなる場合にのみ解を更新する山登り法(Hill Climging approach)と比較したとき、SAは目的関数値が悪くなる場合も確率的に解を更新することからより局所最適値に陥りにくい手法であるといえる。大域的最適解を求める手法であるBranch-and-cutは解が良くなる可能性のある状態空間をすべて探索するのに対し、SAは現在の解の近傍のみを探索している。そのためSAはbranch-and-cutと比較した場合に大域的最適解は求まらない可能性があるが、高速に近似解を求められる利点がある。
	
	%2. どう言う特徴なのか. 温度と確率に関して
	SAは目的関数値が悪くなる場合に遷移する確率のパラメータとして温度をもつ。
	温度が高いほど様々な解を探索する確率が高く、温度が低いほど目的関数地が向上する解にのみ遷移する確率が高まる。
	通常は高い初期温度から徐々に低い最終温度へと下げていく。これにより、広い解を探索しながら最終的には収束するようなスケジュールとすることができる。
	遷移確率は通常、目的関数地が良くなる場合には１をとり、それ以外の場合には温度に応じた確率関数として設計する。
	ここでは一例としてkirkpatrickらが示した最小化問題に対する遷移確率関数を示す。ここで$s$は現在の状態、$s`$は次の状態、$T$は温度とする。
	\begin{equation}  \label{eq: probFunction}
		P(s, s`, T)=
		\begin{cases*}
			1   &   if\ $s`<s$  \\
			exp (\frac{s-s`}{T})     &   if\ $s`\geq s$ 
		\end{cases*}
	\end{equation}
	
	
	最小化問題に対する焼きなまし法の疑似アルゴリズムの一種(アルゴリズム\ref{alg:SimulatedAnnealing})を示す。このアルゴリズムは目的関数値との誤差を終了条件に含んでいないため最終結果を保証できないが、現実的な時間で近似解を求めることができる。
	
	
	\begin{algorithm}[tb]
		\caption{焼きなまし法}
		\label{alg:SimulatedAnnealing}
		\begin{algorithmic}[1]
			\STATE イテレーション数$k = 0$と最大イテレーション数$k_{max}$をとる
			\STATE 初期状態$state$を一つとり、最良状態$bestState$とする。その時の目的関数値$score$を最良スコア$bestScore$とする。
			\WHILE{$k<k_{max}$}
			% 	\WHILE{$N \neq 0$}
			\STATE $k, k_{max}$をもとに現在の温度tempを求める。
			\STATE 新しい状態$newState$を得る。
			\STATE 新しい状態の目的関数値$newScore$を得る。
			\STATE $temp$と$newScore,score$をもとに遷移確率$prob$を求める。$newScore<score$である場合$prob=1$を満たすとする。
			\IF{$newScore < bestScore$}
			\STATE $bestScore \Leftarrow newScore$
			\STATE $bestState  \Leftarrow newState$
			\ENDIF
			\STATE $rand$を[0,1]の乱数として得る。
			\IF{$rand<prob$}
			\STATE $state \Leftarrow newState$
			\STATE $score  \Leftarrow  newScore$
			\ENDIF
			\ENDWHILE
			\STATE $bestState$を出力する
		\end{algorithmic}
	\end{algorithm}
	
	
	
	\subsection{Larasatiらの手法}\label{larasati}
	larasatiらの手法\cite{larasati2022integrated}、特にCVTSPを得ヒューリステックであるアルゴリズム\ref{alg:larasati}について解説する。このアルゴリズムにおいて、$x_0$は解の一つ、$f(x_0)はx_0$における目的関数値を表す。
	
	
	
	\begin{algorithm}[tb]
		\caption{ALG-SA}
		\label{alg:larasati}
		\begin{algorithmic}[1]
			\STATE INPUT:目的地の座標
			\STATE 初期温度$T_{first}$, 目標温度$T_{last}$, 最大ステップ数$S_{max}$とする
			\WHILE{$T_k>T_{last}$}
			\FOR{新規の解の数$n_{solution}$}
			\STATE 新しい解$x_0+\Delta x$を取る。
			\IF{$f(x_0+\Delta x)<f(x_0)$}
			\STATE $f_{new} \Leftarrow f(x_0+\Delta x)$
			\STATE $x_0 \Leftarrow x_0+\Delta x$
			\ELSE
			\STATE $\Delta f \Leftarrow f(x_0+\Delta x) - f(x_0)$
			\STATE rを0から１の乱数として取る。
			\IF{$r>exp(\Delta f/T)$}
			\STATE $f_{new} \Leftarrow f(x_0+\Delta x)$
			\STATE $x_0 \Leftarrow x_0+\Delta x$
			\ELSE
			\STATE $f_{new} \Leftarrow f(x_0)$
			\ENDIF
			\ENDIF
			\ENDFOR
			\STATE $f \Leftarrow f_{new}$
			\STATE $k\Leftarrow k+1$
			\STATE 温度$T_k$を線形関数で更新する。
			\ENDWHILE
			\STATE 最適な訪れる順序$x_0$を出力
		\end{algorithmic}
	\end{algorithm}
	
	数値実験の結果\cite{larasati2022integrated}として、目的地の数が3から9の範囲では最適値との誤差が1\%未満、11から15の範囲では10\%未満であった。
	また、計算時間に関しては、25点で0.57秒ほどであった。
	一方、GUROBIでは13点以上になると1800秒では求解ができなかった。よってlarasatiらが提案した手法は、ターゲット数が増えるほど有用であるといえる。
	
	\clearpage
	\section{問題設定}\label{sec:Second_Order_Cone_Programming_without_interiorpoint}
	\subsection{問題の定義}\label{sec:problem_settings}
	本研究が対象とするCVTSPWT (Carrier Vehicle Travering Salesman Problem with Time Window)についての説明を与える。
	
	CVTSPWTには異なった性質を持つ二種類の乗り物を用いる。
	\begin{itemize}
		\item[vehicle] 速度が速く直接目的地に向かうのに用いる。しかしバッテリー量に限界があり一回の航行可能距離には上限が存在する。そのため、目的地に近づくまではcarrierによって運ばれる。バッテリー量はcarrierと合流すると上限まで戻る。バッテリー交換に要する時間は0とする。
		\item[carrier] 速度が遅いため直接目的地に向かうのに用いず、離陸地点までvehicleを輸送したのち着陸地点まで移動しvehicleを回収する用途で用いる。移動距離に上限は存在しない。
	\end{itemize}
	以後vehicleとcarrierが分離することを離陸、vehicleとcarrierが合流することを着陸と呼ぶ。
	
	この問題の目的は座標$q_o$から出発し、すべての目的地を訪れた後$q_f$に至るまでの時間の最小化である。移動に関してユークリッド平面上の任意の点に移動することができ、離着陸点も任意の座標を指定できる。目的地$q_i$には時間制約$(u_{i1}, u_{i2})$が設定されており、この時間内に必ず訪れなければならない。
	本問題に対して時間制約を$(0,\infty)$としドローンの航続可能距離を0とするとTSPと同じ設定となることから、TSPより少なくとも難しい問題である。
	
	目的地の数が3である場合の例を示す。座標と時間枠をそれぞれ表\ref{tb:settings_sample}で定義する。このときの最適ルートと離着陸点を図示すると図\ref{fig:settings_sample}となる。
	$q_o$から最も近い目的地である$q_2$を訪れる場合時間枠の開始時間より早く到着してしまいその場所で停止する必要があるため、より開始時間が早い$q_3$を先に訪れていることが分かる。
	
	\begin{table}[htbp]
		\centering
		\caption{問題例}
		\begin{tabular}{l|l|l}
			名称 & 座標 & 時間枠 \\ \hline\hline
			$q_o$ & (0,0) & None \\
			$q_f$ & (50,50) & None \\ \hline
			$q_1$ & (45,45) & (0,4) \\
			$q_2$ & (10,40) & (3,6) \\
			$q_3$ & (30,20) & (2,6) \\ \hline \hline
		\end{tabular}
		\label{tb:settings_sample}
	\end{table}
	%todo: 初期位置はp_o, p_fである。
	\begin{figure}[htbp]
		\centering
		\includegraphics[scale = 0.70]{resources/settings_sample.png}
		\caption{問題例の最適解}
		\begin{minipage}[c]{0.7\hsize}
			青色の丸は開始地点、終了地点、目的地のいずれかを表す。赤色の丸は離陸地点、赤色の四角は着陸地点を表す。黒の実線はcarrierとvehicleが同時に移動している箇所を表し、赤の点線はcarrierのみ青の点線はvehicleのみが移動している箇所を表す。
		\end{minipage}
		\label{fig:settings_sample}
	\end{figure}
	
	\subsection{MISOCPとして定式化}\label{sec:formulation_as_MISOCP}
	% cplexの解法は数値実験章で比較するのみ
	% 誰の既存研究の結果を用いているかを必ず明記する。
	ここでは、対象問題を解くためのモデルをMISOCPを用いて定式化する。これは、Gambellaらの先行研究\cite{gambella2018exact}の拡張である。
	
	まずは定数を定義する。
	\begin{itembox}[l]{定数}
		\begin{description}
			\item[$n \in \mathbb{N}$]目的地の数
			\item[$\q_i \in \Real^2, i=1,\dots,n$]目的地$i$の座標
			\item[$\q_{min}\in \Real^2$] $\q_i$の下限
			\item[$\q_{max}\in \Real^2$]  $\q_i$の上限
			\item[$V_v\in \Real_+$] vehicleの速さ
			\item[$V_c\in \Real_+$] carrierの速さ
			\item[$a\in \Real_+$] vehicle が一回の輸送で移動できる距離の上限
			\item[$\p_o\in \Real^2$]輸送パスの開始座標
			\item[$\p_f\in \Real^2$]輸送パスの終了座標
			\item[$\u_{i1}\in \Real^2, i=1,\dots,n$] 目的地$i$の受け入れ開始時間
			\item[$\u_{i2}\in \Real^2, i=1,\dots,n$] 目的地$i$の受け入れ終了時間
		\end{description}
		\label{tb:constant}
	\end{itembox}
	Gambellaらの研究の定数に時間枠$\u$を加え拡張した。
	下限と上限に関して詳しく説明する。
	下限は$q_i$が以下の条件を満たすよう制約するものである。
	$q_{min,1}\leq q_{i,1}, q_{min,2}\leq q_{i,2}, i = 1,\cdots,n$
	同様に、上限は$q_i$が以下の条件を満たすよう制約するものである。
	$q_{max,1}\geq q_{i,1}, q_{max,2}\geq q_{i,2}, i = 1,\cdots,n$
	
	次に決定変数を定義する。
	
	\begin{itembox}[l]{変数}
		\begin{description}
			\item[$\Q_i\in \Real^2, i=1,\dots,n$] $i$番目に訪れる目的地の座標
			\item[$\w_{ij} \in \{0,1\}^{n\times n}, i=1,\dots,n,j=1,\dots,n$] $i$番目に目的地jに訪れる場合を１、それ以外を0とするバイナリ変数
			\item[$\p_{to, i}\in \Real^2, i=1,\dots,n$] $\Q_i$にむけて離陸するときの座標
			\item[$\p_{l, i}\in \Real^2, i=1,\dots,n$] $\Q_i$を訪れた後に着陸するときの座標
			\item[$\t_{i,1}\in \Real,i=1,\dots,n$] vehicleが$\p_{to, i}$ から $\Q_i$に移動するのにかかる時間
			\item[$\t_{i,2}\in \Real,i=1,\dots,n$]vehicleが$\Q_i$から$\p_{l, i}$に移動するのにかかる時間
			\item[$\t_i\in \Real,i=1,\dots,n$] carrierが$\p_{to, i}$から$\p_{l, i}$に移動するのにかかる時間
			\item[$T_1\in \Real$] carrierが$\p_o$から  $\p_{to, 1}$に移動するのにかかる時間
			\item[$\T_i\in \Real,i=2,\dots,n$] carrierが$\p_{l, i-1}$から  $\p_{to, i}$に移動するのにかかる時間
			\item[$T_{n+1}\in \Real$] carrierが$\p_{l,n}$から  $\p_{f}$に移動するのにかかる時
			\item[$\U_{i1}\in \Real^2, i=1,\dots,n$] $\Q_i$の受け入れ開始時間
			\item[$\U_{i2}\in \Real^2, i=1,\dots,n$] $\Q_i$の受け入れ終了時間
		\end{description}
	\end{itembox}
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[scale = 0.7]{resources/variables.png}
		\caption{例}
		\begin{minipage}[c]{0.7\hsize}
			青色の丸は開始地点、終了地点、目的地のいずれかを表す。赤色の丸は離陸地点、赤色の四角は着陸地点を表す。黒の実線はcarrierとvehicleが同時に移動している箇所を表し、赤の点線はcarrierのみ青の点線はvehicleのみが移動している箇所を表す。
		\end{minipage}
		\label{fig:definition_sample}
	\end{figure}
	
	図(\ref{fig:definition_sample})は青丸で示した$q_1, q_2$に対するCVTSPTWの実行可能解の一つである。
	この時、$q_2, q_1$の順番で訪れていることから、$Q_1 = q_2, Q_2=q_1$となる。よって
	$\w = 
	\begin{bmatrix}
		0 & 1 \\
		1 & 0 \\
	\end{bmatrix}
	$
	である。
	時間制約に関して、$U_{1,1}<T_1+t_{1,1} <U_{1,2}, U_{2,1}<T_1+t_{1,1}+T_2+t_{2,1}<U_{2,2}$を満たせば十分であることもわかる。
	
	
	問題をMISOCPとしてモデル化する。
	\mathtoolsset{showonlyrefs=false}
	\begin{eqnarray}
		\label{eq:formulation}
		\min & : & \sum_{i=1}^{n}t_i+\sum_{i=1}^{n+1}T_i \label{obj}\\
		\text{subject to} & : &\|Q_i - p_{to,i}\|\leq V_v t_{i, 1}\ (\forall i = 1,\dots ,n)\label{cst1}\\
		& & \|Q_i - p_{l,i}\|\leq V_v t_{i, 2}\ (\forall i = 1,\dots ,n)\label{cst2}\\
		& & \|p_{to,i} - p_{l,i}\|\leq V_c t_i\ (\forall i = 1,\dots ,n)\label{cst3}\\
		& & \|p_o - p_{to,1}\|\leq V_c T_1\label{cst4}\\
		& & \|p_{l,i-1}- p_{to,i}\|\leq V_c T_i\ (\forall i = 2,\dots ,n)\label{cst5}\\
		& & \|p_f- p_{l,n}\|\leq V_c T_{n+1}\ \label{cst6}\\
		& & t_{i,1}+t_{i,2}\leq t_i \ (\forall i = 1,\dots ,n)\label{cst7}\\
		& & Q_i = \sum^n_{j=1}{w_{i,j}q_j}\ (\forall i = 1,\dots ,n)\label{cst8}\\
		& & \sum^n_{j=1}{w_{i,j}} = 1\ (\forall i = 1,\dots ,n)\label{cst9}\\
		& & \sum^n_{i=1}{w_{i,j}} = 1\ (\forall j = 1,\dots ,n)\label{cst10}\\
		& & t_{i,1}\geq 0\ (\forall i = 1,\dots ,n)\label{cst11}\\
		& & t_{i,2}\geq 0\ (\forall i = 1,\dots ,n)\label{cst12}\\
		& & 0\leq t_1 \leq a \ (\forall i = 1,\dots ,n)\label{cst13}\\
		& & T_i\geq 0\ (\forall i = 1,\dots ,n)\label{cst14}\\
		& & q_{min}\leq Q_i \leq q_{max}\ (\forall i = 1,\dots ,n)\label{cst15}\\
		& & w_{ij} \in \{0,1\}\ (\forall i = 1,\dots ,n,\forall j = 1,\dots ,n)\label{cst16}\\
		& & U_{i,1} \leq T_1+t_{1,1}+ \sum_{j=1}^{i-1}{t_{j,2}+T_{j+1}+t_{j+1, 2}} \leq U_{i,2}\label{cst17}\\
		& & U_{i,1} = \sum^n_{j=1}{w_{i,j}u_{i,1}}\ (\forall i = 1,\dots ,n)\label{cst18}\\
		& & U_{i,2} = \sum^n_{j=1}{w_{i,j}u_{i,2}}\ (\forall i = 1,\dots ,n)\label{cst19}
	\end{eqnarray}
	\mathtoolsset{showonlyrefs=true}
	
	目的関数(\ref{obj})は総行程にかかる時間、具体的にはcarrierが$q_o$を出発し、vehicleがすべての目的地をたどり$q_f$に至るまでの時間の総和である。
	制約式(\ref{cst1})(\ref{cst2})はvehicleが$p_{to,i}$から離陸して$Q_i$に至る時間、$Q_i$から$p_{l,i}$に着陸する時間をそれぞれ表している。(\ref{cst3})はcarrierが$p_{to,i}$から$p_{l,i}$に至る時間を表している。
	このときvehicleとcarrierは分離している点に注意する。
	制約式(\ref{cst4})-(\ref{cst6})はcarrierとvehicleが同時に移動しているときの時間を表している。
	(\ref{cst7})はvehicleがcarrierより早く着陸地点に到着して待たないことを制約している。
	(\ref{cst8})はi番目に訪れる座標が$q_j$であることを保証するための制約である。
	(\ref{cst9}),(\ref{cst10})はそれぞれi番目に訪れる目的地は1つであること、各目的地には一度訪れることを保証している。(\ref{cst11})-(\ref{cst15})はぞれぞれvehicle, carrierの移動時間が負とならないことを保証している。
	特に(\ref{cst13})はvehicleが移動できる時間の上限を$a$で制限している。
	(\ref{cst17})は各時間制約に違反しないことを保証するための制約である。
	具体的には、各目的地$Q_i$に訪れるまでのvehicleの移動時間の総和$T_{sum,i}$が$T_{sum,i} \in [U_{i,1},U_{i,2}]$を満たすことを保証している。(\ref{cst18}),(\ref{cst19})は$Q_i$に対応する時間窓を割り当てるための制約である。
	
	制約式(\ref{cst1})-(\ref{cst6})は二次錐制約であり(\ref{cst7})-(\ref{cst19})は線形制約であること、決定変数$w_{ij}$は整数制約を持つためこのモデルはMISOCPである。
	
	\clearpage
	\section{提案手法}\label{sec:SimulatedAnnealing}
	
	
	% ヒューリスティックを強調した章の名前にしてもいいかも
	% 問題を２ステップに分けて考える。辿る順番を求めるパートと、位置を決めるパート
	% 辿る順番を決めるのにSAを用いる
	% 辿る順番は組合せ最適化問題であり、選び方が途方もなくあるため全部見るのは困難
	%　よってこのパートはヒューリスティックを用いて克服する
	% 初期回の生成を緩和問題をソルバーで解くことにより効率化できる旨も記す。
	本章では提案手法について述べる。
	Larasati et al(2022)\cite{larasati2022integrated}を参考にし、CVTSPWTに対して使えるよう拡張した。
	時間制約をつけるために、目的地を訪れる順番が決まった後の離着陸地点を決める問題に対して\ref{eq:formulation}で定義した最適化問題を用いる。
	
	提案するアルゴリズムは1.訪れる順番を決める離散最適化問題,2.最適な離着陸点を決める連続最適化問題の２つの最適化問題を解くことで近似解をもとめるものである。
	もともとの問題はMISOCPであり、CPLEXやGUROBIなどのMISOCPを扱える既存のソルバーを用いれば厳密解の求解が可能であるが、長時間の計算時間が必要である。
	一方たどる順番が与えられて最適な離着陸地点を求める問題はSOCPとなり高速にソルバーを用いて最適解が求まる。
	
	最適な訪れる順番を決める問題は、離散計画問題であり一般に汎用ソルバーを用いての計算には非常に時間がかかる。そこで本論文ではメタヒューリスティックの一種である焼きなまし法を用いて解の探索を行う。焼きなまし法では、局所最適解をなるべく避けるために、解の評価値が悪化する場合も確率的に遷移する特徴を持つため、すべての状態を列挙する方法や、解が改善された場合のみ遷移を行う方法と比べて、効率的に良い解が得られる。
	
	提案手法のアルゴリズム\ref{alg:proposedMethod}の詳細を示す。このアルゴリズムは\ref{sec:SA}章で示した焼きなまし法をベースとした手法である。
	
	まずは提案手法の中で用いている関数を提示する。
	初期状態を得る関数$getFirstState()$, 次の状態を得る関数$getNextState()$, 状態に対する目的関数値を得る関数$getScore()$, 遷移確率を計算する関数$getProb()$, 温度を計算する関数$getTemp()$をそれぞれ定義する。
	状態$state$は目的地を訪れる順番を表す行列とする。
	
	\begin{algorithm}[tb]
		\caption{提案手法}
		\label{alg:proposedMethod}
		\begin{algorithmic}[1]
			\STATE INPUT:目的地と開始終了地点の座標、目的地の時間枠
			\STATE 定数の設定:初期温度$T_{first}$, 目標温度$T_{last}$,イテレーション回数$k_{max}$
			\STATE $k \Leftarrow 0$
			\STATE $state \Leftarrow getFirstState()$
			\STATE $score \Leftarrow getScore(state)$
			\STATE $bestState \Leftarrow state, bestScore \Leftarrow score$
			\WHILE{bestStateが実行可能解でない、または、前回のループでbestScoreが更新された}
			\WHILE{$k<k_{max}$}
			\STATE $temp \Leftarrow getTemp(k, k_{max})$
			\STATE $newState \Leftarrow getNextState(state)$
			\STATE$ newScore \Leftarrow getScore(newState)$
			\STATE $prob \Leftarrow getProb(temp,newScore,score)$
			\IF{$newScore < bestScore$}
			\STATE $bestScore\Leftarrow newScore$
			\STATE $bestState \Leftarrow newState$
			\ENDIF
			\STATE $rand \Leftarrow random(0,1)$
			\IF{$rand<prob$}
			\STATE $state \Leftarrow newState$
			\STATE $score  \Leftarrow  newScore$
			\ENDIF
			\ENDWHILE
			\ENDWHILE
			\STATE OUTPUT:$bestState, bestScore$がそれぞれ最適解と最適値
		\end{algorithmic}
	\end{algorithm}
	
	\mathtoolsset{showonlyrefs=false}
	$ state$を受容する確率を計算する関数を式\ref{eq: getProb}で定義する。
	遷移確率はスコアが改善していれば1, そうでなければ0以上1以下の正実数を返す必要がある。スコアが改善しているほど1に近いことと温度が高いほど遷移しやすいことを表現するために\ref{sec:SA}章で紹介した以下の定義を用いる。
	\begin{equation}  
		getProb(temp,newScore,score)=
		\begin{cases*}
			1   &   if\ $newScore<score$  \\
			exp (\frac{score-newScore}{temp})     &   if\ $newScore\geq score$ 
		\end{cases*}
		\label{eq: getProb}
	\end{equation}
	
	現在の試行回数から、温度パラメータを計算する関数を式\ref{eq: getTemp}で定義する。
	温度は初期の大きい値$firstTemp$から最終的な小さい値$lastTemp$へと徐々に下がっていくように設計する。
	今回の関数は$k$に対する単調減少な線形関数であり、線形スケジュールと呼ばれる。
	\begin{equation}  \label{eq: getTemp}
		getTemp(k, k_{max})=firstTemp+\frac{k}{k_{max}}(lastTemp-firstTemp)
	\end{equation}
	
	
	初期状態を求める関数を式\ref{eq: getFirstState}で定義する。
	初期状態は、アルゴリズムを実行する時の最初の解であり、高速で求められることが望ましい。
	初期状態は一般的にランダムに求められることが多く、そのような場合でも適切に実行すれば焼きなまし法は収束する。
	本論文でもたどる順番がランダムと成るような解を返す関数として構成している。
	
	\begin{equation}  \label{eq: getFirstState}
		getFirstState()=
		単位行列\I　の任意の数の行または列を入れ替えた行列\\
	\end{equation}
	
	状態のスコアを求める関数を式\ref{eq: getScore}で定義する。
	本論文では、スコアを\ref{sec:formulation_as_MISOCP}章で定義した最適化問題の状態ｗを決定変数でなく入力とした最適化問題を構成し、その最適値として定義する。
	この変換により、整数変数がなくなるため、モデルのクラスがMISOCPからSOCPとなり、高速な求解が可能となる。
	ここで、スコアとは状態と理想とする状態との近さを表現できていればよく、必ずしも最適化問題の最適値でなくても良いことに注意する。
	
	それぞれの目的地に対して訪れることが可能な時間枠の制約があるため、入力された順番によっては実行可能な離着陸地点が存在しない場合がある。
	その場合は通常の最適化問題であれば解なしとなり最適値が求まらないが、焼きなまし法では繰り返しの処理の中で解の評価を行う必要があるため、今回は一定の大きい値を代わりに返すことで解の評価値の代わりとしている。
	
	\begin{equation}  \label{eq: getScore}
		getScore(state)=
		\begin{cases*}
			SOCPの最適値   &   if\ stateに対して実行可能な解が存在する  \\
			$M$     &   if\ stateに対して実行可能な解が存在しない\\
		\end{cases*}\\ 
	\end{equation}
	ただし、$M$は十分大きい実数
	
	状態を入力として新たな状態を求める関数getNextStateを定義する
	焼きなまし法では、もとの状態を少し変化させたものを新しい状態として得ることが多く、この新たな状態を近傍と呼ぶ。
	本論文では近傍を2-swapとして得る。
	2-swapは、現在の訪れる順番のうち、任意の二箇所を選び、それらを入れ替える操作として定義する。
	通常のTSPでは訪れる経路の中で交差している箇所の交差を解消する操作である2-optも効果的である。
	
	\mathtoolsset{showonlyrefs=true}
	
	図(\ref{fig:solved_by_proposed_method})は提案手法を用いて、目的地数が9の問題インスタンスを作成し、実際に解いたときの画像である。
	
	
	
	\begin{figure}[htbp]
		\begin{minipage}[l]{0.5\hsize}
			\centering
			\includegraphics[scale = 0.45]{resources/example_instance.png}
		\end{minipage} 
		\begin{minipage}[c]{0.5\hsize}
			\centering
			\includegraphics[scale = 0.45]{resources/example_solved_SA.png}
		\end{minipage} 
		\caption{提案手法を用いてCVTSPWTを解いた例}
		\label{fig:solved_by_proposed_method}
	\end{figure}
	
	\clearpage
	\section{数値実験}\label{sec:Numerical_Experience}
	この章では、CVTSPWTのデータセットを作成し、実際に提案手法を用いて解くことでその性能を評価する。本論文では、SOCPを解くソルバーとして、IBM社のCPLEXを用いた。
	
	実験を行った実行環境は以下である。
	\begin{itemize}
		\item OS: macOS Monterey 12.6.2
		\item プロセッサ:Intel Dual Core i5 1.6 GHz
		\item RAM: 8.0GB
		\item プログラミング言語: Julia
	\end{itemize}
	
	\subsection{パラメータの設定}\label{sec:parameter_settings}
	%TODO: 引用元を示す。aをもう少し詳しく説明する。
	\ref{tb:constant}章で定義した定数を数値実験では表\ref{tb:constan_setting}として定める。
	
	\begin{table}[htbp]
		\centering
		\caption{定数の設定}
		\begin{tabular}{|l|c|}
			\hline
			定数 & 値  \\ \hline\hline
			$n$ & 問題ごとに設定する  \\
			$q_i$ & \ref{sec:Problem_Generation}章にて生成する  \\ 
			$q_{min}$ & (0,0)  \\
			$q_{max}$ & (60,60) \\
			$V_v$ & 60 \\
			$V_c$ & 18\\
			$a$ & 21/60  \\
			$p_o$ & (0,0)  \\
			$p_f$ & (50,0)  \\
			$u_{i,1}$ & \ref{sec:Problem_Generation}章にて生成する  \\
			$u_{i,2}$ & \ref{sec:Problem_Generation}章にて生成する  \\ \hline 
		\end{tabular}
		\label{tb:constan_setting}
	\end{table}
	
	提案手法における各種パラメータについても表\ref{tb:approach_parameta}として定める。実際にはデータの性質ごとに調整する必要があるが、本論文では簡単のためにすべて固定する。なお、\ref{sec:relation_with_time_and_score}章の実験の際はイテレータ数を変更しているので注意する。
	%TODO:名前合わせる
	\begin{table}[htbp]
		\centering
		\caption{提案手法のパラメータの設定}
		\begin{tabular}{|l|c|}
			\hline
			パラメータ & 値  \\ \hline\hline
			$Temp_{first}$ & 1  \\
			$Temp_{last}$ & 0.001  \\ 
			$イテレータ数$ & 50 \\
			$実行不可能時の最適化問題の値$ & 500 \\ \hline
		\end{tabular}
		\label{tb:approach_parameta}
	\end{table}
	
	\subsection{問題の生成}\label{sec:Problem_Generation}
	数値実験用のテストデータをアルゴリズム(\ref{alg:generate_problem})を用いて生成する。
	ランダムなｎつの座標をとり、それぞれに時間枠を割り当てるというプロセスで問題生成をおこなう。
	時間枠のサイズにもランダム性をもたせているため、同じ目的地数の問題でも様々な問題例を生成できる。
	
	TODO: アルゴ完成させる。
	\begin{algorithm}[tb]
		\caption{問題生成アルゴリズム}
		\label{alg:generate_problem}
		\begin{algorithmic}[1]
			\STATE 目的地の数$n$を設定する。
			\FOR{$i = 1,\dots,n$}
			\STATE $x \sim Uni(q_{min,1}, q_{max,1}),y\sim Uni(q_{min,2}, q_{max,2})$なる座標$x,y$を取り、$q_i = (x,y)$とする。
			\ENDFOR
			\STATE $i = 1,\dots, k-1$をたどり、$q_k$にたどり着く時間$t_k$をそれぞれ求める。時間は距離の総和をcarrierの速さで割り算出する。
			\STATE 
		\end{algorithmic}
	\end{algorithm}
	
	\subsection{実験結果}\label{sec:Numerical_Result}
	今回の実験の目的地数としてn = (7,9,11,13,15,17,30,50,70)を用い、アルゴリズム\ref{alg:generate_problem}を用いて問題を生成した。
	n = (7,9,11,13,15,17)の問題をsmall instance、n = (30,50,70)のデータをそれぞれlarge instanceと呼ぶ。
	前者は主に既存ソルバーとの性能の比較に用い、後者は提案手法の限界性能を測る目的で用いる。
	small instanceとn=30はそれぞれ７つ、large instanceはそれぞれ3つのデータセットを作成した。
	CPLEXを用いた手法での計測はsmall instanceに対してそれぞれ一回おこなった。
	提案手法を用いた計測では、small instanceに対してそれぞれ10回、large instanceに対してはそれぞれ5回行った。
	
	実験時間が600秒を超えた場合、実行可能解が存在する場合はその時点での最良解を、そうでない場合はTIME OUTを返すものとする。
	
	\begin{table}[htbp]
		\centering
		\caption{CPLEXと提案手法の実験結果}
		\begin{tabular}{|c | c c |c c c c|}
			\hline
			% 手法の名前
			& \multicolumn{2}{c}{CPLEX}& \multicolumn{4}{c}{提案手法}\\
			% 列名
			\begin{tabular}{c}n\\targets\end{tabular}
			% cplex
			&   \begin{tabular}{c}平均\\計算時間\end{tabular}
			&   \begin{tabular}{c}標準偏差\\計算時間\end{tabular}
			%&   \begin{tabular}{c}OptGap\end{tabular}
			% SA
			&   \begin{tabular}{c}平均\\計算時間\end{tabular}
			&   \begin{tabular}{c}標準偏差\\計算時間\end{tabular}
			&   \begin{tabular}{c}平均\\OptGap\end{tabular}
			&   \begin{tabular}{c}標準偏差\\OptGap\end{tabular}\\ 
			\hline \hline
			%contents
			7 
			& 4.686 & 2.409  
			& 5.404 & 0.794 & \begin{tabular}{c}3.646(\%)\\ \end{tabular} &0.037\\
			\hline
			9
			& 10.453 & 8.695 
			& 7.145 & 1.840 & \begin{tabular}{c}5.802(\%)\\ \end{tabular} & 0.0776\\
			\hline
			11
			& 42.565 & 47.487 
			& 21.464 & 4.893 & \begin{tabular}{c}2.186(\%)\\ \end{tabular} & 0.020\\
			\hline
			13
			& 287.809 & 219.355 
			& 10.144 & 1.05 & \begin{tabular}{c}6.027(\%)\\5.987(\%)(*)\\ \end{tabular}& \begin{tabular}{c}0.055\\N/A(*)\\ \end{tabular}\\
			\hline
			15
			& 516.408 & 221.280 
			& 11.949 & 0.896 & \begin{tabular}{c}1.522(\%)\\8.091(\%)(*)\\ \end{tabular} & \begin{tabular}{c}N/A\\0.086(*)\\ \end{tabular}\\
			\hline
			17
			& 600.029 & 0.031 
			& 15.192 & 0.916 & \begin{tabular}{c}10.997(\%)(*) \\ \end{tabular}&0.151\\
			\hline
		\end{tabular}
		\label{tb:result_of_experiment}
	\end{table}
	
	\subsubsection{計算時間と精度の評価}\label{sec:Evaluation_CPUtime_and_accuracy}
	% データの説明
	数値実験の結果は表(\ref{tb:result_of_experiment})に記載している。ここで(*)がついている値は時間制限を超えた時点での最良値であり、値が存在しないものはN/Aとしている。データは各seedでそれぞれ平均をとった値に対し各統計量を求めた。
	提案手法は一つのインスタンスに対しそれぞれ10回実験を行なっている。表の値を算出するにあたり、次のプロセスを踏んだ。まず同じインスタンスの結果を単純に平均を取る。そのデータに対し平均、標準偏差、OptGapを求めた。
	%TODO:OptGapの定義
	$OptGap(\%) =(SA - CPLEX_{opt})/CPLEX_{opt}$
	
	%表からわかること
	表\ref{tb:result_of_experiment}の結果より、CPLEXはnが最大15の場合は最適解を得ることができた。一方、n=13,15,17のいくつかのケースでは最適解を得られなかった。一方、提案手法はどのケースにおいても制限時間内に正常終了していることがわかる。
	
	% 画像５からの考察
	図\ref{fig:opt_gap}は提案手法とCPLEXとのOptGapを表したものである。青色の線は最適解と提案手法との差を、赤色の線は制限時間内の最適なCPLEXの値と提案手法との差を表している。n=17以下の範囲ではCPLEXソルバーと提案手法とのギャップはおおよそ11\%ほどであり、nが増えるほどギャップが大きくなっていることがわかる。提案手法において、精度と実行時間はおおよそトレードオフの関係があるため、精度を高めるためにはイテレータ数を増やすと良いと考えられる。また、アルゴリズムのパラメータである初期温度、最終温度を問題の性質に応じて調整することも精度に寄与すると考えられる。
	
	% 画像6からの考察
	図\ref{fig:computation_time}は提案手法とCPLEXの実行時間を表したものである。CPLEXはnが大きくなるほど実行時間が急速に大きくなっている一方、提案手法では実行時間にそれほど変化がないことがわかる。
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[scale = 0.7]{resources/computation_optgap.png}
		\caption{最適解と提案手法のギャップ}
		\begin{minipage}[c]{0.7\hsize}
			青色の丸は最適値と提案手法の解のギャップの平均を、赤色の三角は制限時間内のCPLEXの最良解と提案手法のギャップの平均を表している。
		\end{minipage}
		\label{fig:opt_gap}
	\end{figure}
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[scale = 0.7]{resources/computation_time.png}
		\caption{target数ごとのCPLEXと提案手法の計算時間の違い}
		\begin{minipage}[c]{0.7\hsize}
			赤色の丸はCPLEXの計算時間の平均を、青色の三角は提案手法の計算時間の平均を表している。
		\end{minipage}
		\label{fig:computation_time}
	\end{figure}
	\subsubsection{実行不可能な場合の考察}
	数値実験において、提案手法が制限時間内に実行可能解を得られなかった場合について考察する。なお、今回の実験で用いるデータはデータ生成の方法から必ず一つ以上の実行可能解を持つ。n=50,70のそれぞれ3つのデータセットを5回実験した結果すべて実行可能解が見つからなかった。
	
	%なぜ
	大きいデータセットにおいて実行可能解が見つからなかった理由について考察する。考えられる理由は2つある。
	１つ目に小さいデータセットと比較して条件が厳しく、実行可能解の濃度が小さい点がある。
	２つ目に、提案手法は近傍が実行不可能である場合は無条件に受け入れている。つまり、解の状態を度外視して探索しているため、イテレーション回数や温度にかかわらずランダムな状態に遷移してしまう問題がある。
	
	%どうすればいい
	上記の問題を克服する方法を考察する。
	１つ目の理由に関しては、問題の性質であるため改善が難しい。
	２つ目の理由に関して、実行不可能の場合には目的関数値が存在しないため、イテレーションに応じて実行可能な状態に近づくスコア関数を設計する。具体的には、時間制約を逸脱している目的地の数の総和などが考えられる。
	\subsubsection{実行時間と目的関数値の関係}\label{sec:relation_with_time_and_score}
	この章では、提案手法のパラメータであるイテレーション回数を変化させた場合に、実験時間と目的関数値が同変化するのかを考察する。
	実験内容は、n=30のデータセットを4つ用い、各データセットに対してイテレーション回数を50,100,200とその結果が\ref{fig:relation_time_with_score}であり、統計量をまとめたものが表\ref{tab:relation_time_with_score}である。
	
	これから、イテレーション回数を大きくするほど実行時間の平均も大きくなっていることがわかる。これはイテレーション中で目的関数値が更新されている間はアルゴリズムを実行し続ける性質のため、一回のイテレーションで多くの近傍を探索するほど更新する確率が上がるためと考えられる。
	またこの性質から、イテレーション回数を大きくするほど目的関数値が大きくなりやすいことも考えられる。
	
	まとめると、イテレーション回数は大きいほど良い結果を得やすいがその分時間がかかるといえる。
	
	
	
	
	\begin{figure}[htbp]
		\begin{tabular}{cc}
			\begin{minipage}[c]{0.5\hsize}
				\centering
				\includegraphics[scale = 0.5]{resources/computation_result_3_1055.png}
				\caption{1055}
			\end{minipage} 
			&
			\begin{minipage}[c]{0.5\hsize}
				\centering
				\includegraphics[scale = 0.5]{resources/computation_result_3_1056.png}
				\caption{1056}
			\end{minipage}
			\\
			\begin{minipage}[c]{0.5\hsize}
				\centering
				\includegraphics[scale = 0.5]{resources/computation_result_3_1057.png}
				\caption{1057}
			\end{minipage} 
			&
			\begin{minipage}[c]{0.5\hsize}
				\centering
				\includegraphics[scale = 0.5]{resources/computation_result_3_1058.png}
				\caption{1058}
			\end{minipage}
			\\
		\end{tabular}
		
		\caption{提案手法における実行時間と精度の関係}
		\begin{minipage}[c]{1\hsize}
			それぞれのグラフは横軸計算時間、縦軸目的関数値のグラフである。図にそれぞれ示している数字は問題生成に用いたseed値であり、表\ref{tab:relation_time_with_score}と対応している。
		\end{minipage}
		\label{fig:relation_time_with_score}
	\end{figure}
	
	\begin{table}[htb]
		\centering
		\caption{提案手法におけるiterateと計算時間、目的関数値の関係}
		\begin{tabular}{|c c|c c c c |} \hline
			seed & iterate & 平均計算時間&標準偏差計算時間&平均目的関数値&標準偏差目的関数値 \\ \hline
			\multirow{3}{*}{1055}
			& 50  & 21.306 &11.547  &20.644  &2.52  \\
			& 100 & 48.471 & 23.076 & 19.469 & 1.171 \\
			& 200 & 83.379 & 50.209 & 19.504 & 1.247\\ \hline
			\multirow{3}{*}{1056}
			& 50  & 65.160 & 51.528 & 33.573 &1.127\\
			& 100 & 77.909& 27.302 & 32.379 & 2.101\\
			& 200 & 131.091& 37.290& 32.129& 1.522\\ \hline
			\multirow{3}{*}{1057}
			& 50  & 39.355&22.235 &32.124 &1.202\\
			& 100 & 42.478& 29.694&34.033 & 0.929\\
			& 200 &62.091 & 20.348& 33.745&0.866 \\ \hline
			\multirow{3}{*}{1058}
			& 50  & 74.875&78.147 & 36.138&1.231\\
			& 100 & 46.787& 28.616& 35.671&0.835 \\
			& 200 & 132.493& 85.886&35.601 & 0749\\ \hline
		\end{tabular}
		\label{tab:relation_time_with_score}
	\end{table}
	
	\clearpage
	\section{まとめと今後の課題}\label{sec:Conclusion}
	本研究では、時間制約付きcarrier-vehicle問題(CVTSPWT)を定義し、問題の一部をSOCPとして定式化し、焼きなまし法と組み合わせて求解を行った。数値実験の結果、CPLEXを用いた方法と比較して高速に近似解がもとまることがわかった。一方、条件が厳しい問題に対しては実行可能解を制限時間内に見つけることができなかった。
	
	本研究に対する今後の課題としては、
	\begin{itemize}
		\item 初期解をランダムではなく距離と時間枠を考慮した方法で作成する。
		\item 選んだ経路が実行不可能である時ランダムに遷移しているが、時間枠を満たしているターゲットの個数を増やすようなスコア関数を構成したい。
		\item 解空間がかなり歪な形をしているため、2-swap以外の近傍関数を構成したい。
	\end{itemize}
	\clearpage
	\section*{謝辞}\label{sec:Acknowledgement}
	
	
	\clearpage
	\begin{small}
		\bibliographystyle{jplain}
		\bibliography{soturon}    
	\end{small}
	
	
\end{document}
