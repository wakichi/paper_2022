\documentclass[11pt,a4paper,dvipdfmx,titlepage,uplatex]{jsarticle}

\usepackage{ascmac}
\usepackage{url}
\usepackage{amssymb}
\usepackage{comment}
\usepackage{amsthm}
\usepackage{amsmath}

\usepackage[dvipdfmx]{hyperref}
\usepackage{pxjahyper}
\setcounter{tocdepth}{3}%目次をサブセクションまで表示

\bibliographystyle{abbrv}


\newtheoremstyle{mystyle}%   % スタイル名
    {}%b                     % 上部スペース
    {}%                      % 下部スペース
    {\normalfont}%              % 本文フォント
    {}%                      % 1行目のインデント量
    {\bfseries}%             % 見出しフォント
    {.}%                     % 見出し後の句読点
    { }%                     % 見出し後のスペース
    {\thmname{#1}\thmnumber{ #2}\thmnote{ (#3)}}

\theoremstyle{mystyle}
\newtheorem{mythm}{定理}[section]

\makeatletter
\renewenvironment{proof}[1][\proofname]{\par
  \pushQED{\qed}%
  \normalfont \topsep6\p@\@plus6\p@\relax
  \trivlist
  \item\relax
  {\bfseries
  #1\@addpunct{.}}\hspace\labelsep\ignorespaces
}{%
  \popQED\endtrivlist\@endpefalse
}
\makeatother

\usepackage{algorithm,algorithmic}

\usepackage{pdfpages}
\usepackage{graphicx}

\usepackage{mathtools}
\mathtoolsset{showonlyrefs=true}

\usepackage{enumerate}
\usepackage{tabularx}
\newcolumntype{Y}{&gt;{\centering\arraybackslash}X} %中央揃え

\usepackage{booktabs}
\usepackage{siunitx}
\usepackage{dcolumn}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{colortbl}
\usepackage{arydshln}

\usepackage{afterpage}%
\usepackage{float}
\usepackage{here}

\usepackage{environ}
\NewEnviron{resizealign}{\sbox0{\let\notag=\relax
		$\begin{matrix}\displaystyle\BODY\end{matrix}$}%
	\sbox1{$(\theequation)$}%
	\sbox2{\parbox{\dimexpr \wd0 + 2\wd1}%
		{\begin{align}\BODY\end{align}}}% for testing
	\noindent\resizebox{\textwidth}{!}{\usebox2}%
}

\usepackage{listings}
\renewcommand{\lstlistingname}{List}
% basicstyle=\ttfamily\small,numberstyle=\ttfamily\footnotesize, numbers=left, frame=single
\lstset{
	% language=c,
	breaklines = true,
	basicstyle=\ttfamily\small,
	commentstyle=\textit,
	% classoffset=1,
	keywordstyle=\bfseries,
	frame=single,
	framesep=5pt,
	showstringspaces=false,
	numbers=left,
	stepnumber=1,
	upquote = true,
	numberstyle=\ttfamily\footnotesize
	% tabsize=2
}

\usepackage{color}
\newcommand{\blue}[1]{\begin{color}{blue}#1\end{color}}
\newcommand{\red}[1]{\begin{color}{red}#1\end{color}}
\newcommand{\green}[1]{\begin{color}{green}#1\end{color}}
\newcommand{\memoblue}[1]{\ifmymemo \begin{color}{memoblue}#1\end{color}\fi}
\newcommand{\modify}[2]{\begin{color}{red}\underline{#1}{#2}\end{color}}

\newcommand{\st}{\textrm{s.t.}}
\newcommand{\Tr}{\mathbf{T}}
\newcommand{\0}{\mathbf{0}}
\newcommand{\diag}{\mathrm{diag}}
\newcommand{\argmin}{\mathrm{argmin}}
\newcommand{\argmax}{\mathrm{argmax}}
\newcommand{\ST}{\mathrm{ST}}
\newcommand{\prox}{\mathrm{prox}}

\newtheorem*{theorem*}{定理}
\newtheorem{theorem}{定理}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem*{proposition*}{Proposition}
\newtheorem{remark}[theorem]{注}
\newtheorem{example}[theorem]{例}
\newtheorem*{remark*}{注}
\newtheorem{lemma}[theorem]{補題}
\newtheorem{assumption}[theorem]{仮定}
\newtheorem{corollary}[theorem]{系}
\newtheorem{definition}[theorem]{定義}
\newtheorem*{definition*}{定義}

\def\br{\hfill\break}
\def\bold#1{\mbox{\boldmath $#1$}}

%
%file name = bflatex.tex
%
\def\0{\mbox{\bf 0}}
\def\1{\mbox{\bf 1}}
\def\2{\mbox{\bf 2}}
\def\3{\mbox{\bf 3}}
\def\4{\mbox{\bf 4}}
\def\5{\mbox{\bf 5}}
\def\6{\mbox{\bf 6}}
\def\7{\mbox{\bf 7}}
\def\8{\mbox{\bf 8}}
\def\9{\mbox{\bf 9}}
\def\a{\mbox{\boldmath $a$}}
\def\b{\mbox{\boldmath $b$}}
% curled charcter can be used by \chige{a}
\let\chige\c

\def\c{\mbox{\boldmath $c$}}

% details are written in  /usr/share/texmf/tex/plain/base/plain.tex
% \newdimen\zhige \zhige=0pt
% \def\chige#1{{\setbox\zhige\hbox{#1}\ifdim\ht\zhige=1ex\accent24 #1%
%  \else\ooalign{\unhbox\zhige\crcr\hidewidth\char24\hidewidth}\fi}}

\def\cc{\mbox{\boldmath $c$}}
\def\d{\mbox{\boldmath $d$}}
\def\e{\mbox{\boldmath $e$}}
\def\f{\mbox{\boldmath $f$}}
\def\g{\mbox{\boldmath $g$}}
\def\h{\mbox{\boldmath $h$}}
\def\i{\mbox{\boldmath $i$}}
\def\j{\mbox{\boldmath $j$}}
\def\k{\mbox{\boldmath $k$}}
\def\l{\mbox{\boldmath $l$}}
\def\m{\mbox{\boldmath $m$}}
\def\n{\mbox{\boldmath $n$}}
\def\o{\mbox{\boldmath $o$}}
\def\p{\mbox{\boldmath $p$}}
\def\q{\mbox{\boldmath $q$}}
\def\r{\mbox{\boldmath $r$}}
\def\s{\mbox{\boldmath $s$}}
\def\t{\mbox{\boldmath $t$}}
\def\u{\mbox{\boldmath $u$}}
\def\v{\mbox{\boldmath $v$}}
\def\w{\mbox{\boldmath $w$}}
\def\x{\mbox{\boldmath $x$}}
\def\y{\mbox{\boldmath $y$}}
\def\z{\mbox{\boldmath $z$}}
\def\A{\mbox{\boldmath $A$}}
\def\B{\mbox{\boldmath $B$}}
\def\C{\mbox{\boldmath $C$}}
\def\D{\mbox{\boldmath $D$}}
\def\E{\mbox{\boldmath $E$}}
\def\F{\mbox{\boldmath $F$}}
\def\G{\mbox{\boldmath $G$}}
\def\H{\mbox{\boldmath $H$}}
\def\I{\mbox{\boldmath $I$}}
\def\J{\mbox{\boldmath $J$}}
\def\K{\mbox{\boldmath $K$}}
\def\L{\mbox{\boldmath $L$}}
\def\M{\mbox{\boldmath $M$}}
\def\N{\mbox{\boldmath $N$}}
\def\O{\mbox{\boldmath $O$}}
\def\P{\mbox{\boldmath $P$}}
\def\Q{\mbox{\boldmath $Q$}}
\def\R{\mbox{\boldmath $R$}}
\def\S{\mbox{\boldmath $S$}}
\def\T{\mbox{\boldmath $T$}}
\def\U{\mbox{\boldmath $U$}}
\def\V{\mbox{\boldmath $V$}}
\def\W{\mbox{\boldmath $W$}}
\def\X{\mbox{\boldmath $X$}}
\def\Y{\mbox{\boldmath $Y$}}
\def\Z{\mbox{\boldmath $Z$}}
\def\AC{\mbox{$\cal A$}}
\def\BC{\mbox{$\cal B$}}
\def\CC{\mbox{$\cal C$}}
\def\DC{\mbox{$\cal D$}}
\def\EC{\mbox{$\cal E$}}
\def\FC{\mbox{$\cal F$}}
\def\GC{\mbox{$\cal G$}}
\def\HC{\mbox{$\cal H$}}
\def\IC{\mbox{$\cal I$}}
\def\JC{\mbox{$\cal J$}}
\def\KC{\mbox{$\cal K$}}
\def\LC{\mbox{$\cal L$}}
\def\MC{\mbox{$\cal M$}}
\def\NC{\mbox{$\cal N$}}
\def\OC{\mbox{$\cal O$}}
\def\PC{\mbox{$\cal P$}}
\def\QC{\mbox{$\cal Q$}}
\def\RC{\mbox{$\cal R$}}
\def\SC{\mbox{$\cal S$}}
\def\TC{\mbox{$\cal T$}}
\def\UC{\mbox{$\cal U$}}
\def\VC{\mbox{$\cal V$}}
\def\WC{\mbox{$\cal W$}}
\def\XC{\mbox{$\cal X$}}
\def\YC{\mbox{$\cal Y$}}
\def\ZC{\mbox{$\cal Z$}}

\def\Real{\mbox{$\mathbb{R}$}}
\def\Complex{\mbox{$\mathbb{C}$}}
\def\SMAT{\mbox{$\mathbb{S}$}}
\def\Integer{\mbox{$\mathbb{Z}$}}
\def\Natural{\mbox{$\mathbb{N}$}}
\def\ascript{\mbox{\scriptsize $\a$}}
\def\blambda{\mbox{\boldmath $\lambda$}}
\def\etab{\mbox{\boldmath $\eta$}}
\def\balpha{\mbox{\boldmath $\alpha$}}
\def\bbeta{\mbox{\boldmath $\beta$}}
\def\bzeta{\mbox{\boldmath $\zeta$}}
\def\bmu{\mbox{\boldmath $\mu$}}

\newcommand{\oz}{\overline{z}}
\newcommand{\oc}{\overline{\c}}
\newcommand{\ob}{\overline{\b}}
\newcommand{\cO}{\mathcal{O}}
\title{{\large 令和5年度　学士論文}\\ \vskip\baselineskip
時間制約付きcarrier vehicle routing問題に対する\\二次錐計画問題を用いた解法}
\author{東京工業大学　情報理工学院　数理・計算科学系\\
学籍番号　19B31048\\
脇田康平\\
指導教員 山下 真 教授\\
}
\date{2023年2月27日}
\begin{document}

\maketitle

\tableofcontents
\clearpage

\section{はじめに}\label{sec:introduction}
% 研究の大まかな内容
% 研究の意義
% 論文の構成

本論文の構成は以下である。
第\ref{sec:preliminaries}節では、二次錐計画問題(SOCP)に関する前提知識として二次錐計画問題と内点法アルゴリズム、中心パスなどについて説明をする。
第\ref{sec:Deformation_relax_and_penalty}節では、緩和法とペナルティ法に基づく変形について説明する。
第\ref{sec:Numerical_Experience}節では、数値実験を行った結果を示し、各手法の評価を行う。
第\ref{sec:Conclusion}節で、まとめを行う。

\subsection{記法}\label{sec:notation}


この論文で扱う記法を述べる。
\begin{itemize}
  \item $\|\cdot\|$はユークリッドノルムとする。
  \item 行列$\A \in \Real^{k \times m} , \B \in \Real^{k \times n}$を横方向につなげてできる新たな行列$\C \in \Real^{k \times (m+n)}$を
  $ \C = (\A, \B)$ と表記する。
  \item 行列$\A \in \Real^{m \times k} , \B \in \Real^{n \times k}$を縦方向につなげてできる新たな行列$\C \in \Real^{(m+n) \times k}$を
$    \C = (\A ; \B)$ と表記する。
  \item 上付き添え字 $T$ は行列やベクトルの転置を示す。
  \item $\x^T \y$はベクトル$\x,\y \in \Real^n$の内積$\sum_{i=1}^n x_i y_i$である。
  \item ２つのベクトル$\x , \y \in \Real^n$に対して、$\x \circ \y$を次のように定義する。\\
$\x \circ \y = \left(
  \begin{array}{c}
    \x^T \y \\
    x_0 y_1 + y_0 x_1 \\
    \vdots \\
    x_0 y_n + y_0 x_n
  \end{array} \right)
  $
  \item ２つの行列$\A , \B$に対して$\A \oplus \B =
  \begin{pmatrix}
    \A & \0 \\
    \0 & \B \\
  \end{pmatrix}$
  \item $n$次元のベクトル$\e \in \Real^n$かつ、$1$番目の要素のみが$1$で、その他の要素は全て$0$であるベクトルを$\e_n = (1 ; \0)$と表す。
  \item 対角成分以外は0で、対角成分は1行目が$1$,それ以外が$-1$である行列を$\R_n \in \Real^{n \times n}$とする。
  $
  \R_n =
  \begin{pmatrix}
    1 & 0 & \cdots & 0 \\
    0 & -1 & \cdots & 0 \\
    \vdots & \vdots & \ddots & \vdots \\
    0 & 0 & \cdots & -1 \\
  \end{pmatrix}
  $
\end{itemize}

\clearpage

\section{先行研究}\label{sec:preliminaries}
% MISOCPで定義する論文と焼きなましの論文の二つを紹介する。
\subsection{An integrated integer programming model with a simulated annealing heuristic for the carrier vehicle traveling salesman problem}
時間制約なし焼きなまし解法
\subsection{Exact Solutions for the Carrier Vehicle Traveling Salesman Problem}
Gambellaらの手法を概説する。本研究では時間制約がない場合のCVTSPを対象としている。本論文で着目すべきはCVTSPをMISOCPとして定式化をしている点であり、これは時間制約付きに容易に拡張できる点で非常に理想的といえる。\\
\section{問題設定}\label{sec:Second_Order_Cone_Programming_without_interiorpoint}
\subsection{対象とする問題について}\label{sec:problem_settings}
本研究が対象とするCVTSPWT(Carrier Vehicle Travering Salesman Problem with Time Window)についての説明を与える。\\
この問題では、速度$V_c$であるcarrierと 速度$V_v$であるvehicleの二つの輸送機器を用いる。ただし, $V_c< V_v$\\
CVTSPWTとは以下の条件を満たすcarrierの経路のうち、スタート地点($q_s$)からゴール地点($q_f$)まで最も少ない時間で航行できる経路とその時間を求める問題である。\begin{enumerate}
	\item どの目的地にも少なくとも一回訪れる。その際、訪れるのはvehicleでもcarrierでも良い\\
	\item ある目的地iには$(u_{i1}, u_{i2})$の間の時間に訪れる。\\
	\item  vehicleには一度に航行できる距離$a$があり、これを超えてはいけない。航行可能距離は、carrierと同じ座標に来たら再び$a$に戻る。\\
	\item vehicleはcarrierから離陸して着陸するまでの間に一箇所しか訪れられない。

\end{enumerate}
本問題に対してドローンの航続可能距離を０とするとTSPと同じ設定となることから、TSPより少なくとも難しい問題である。

\subsection{混合整数二次錐計画問題}\label{sec:Second_Order_Cone_Programming}
二次錐$\mathcal(K)$
これを用いて二次錐計画問題(SOCP)の一般的な形は(数式)と表せる。\\
SOCPをノルムを用いて変形すると以下の数式のように表せる。\\
\begin{align}
	\begin{array}{rcl}
		\min & : & \f ^T\x \\
		\text{subject to} & : &||\A_i x +\b_i||_2 \leq \c_i^T\x+\d_i, i = 1,\dots, m \\
		& & \F\x=\g\\
	\end{array}
\end{align}

二次錐計画問題はノルムを扱えるため汎用性が高いだけでなく、ソルバーを用いて高速で求解をすることができるという特徴がある。\\
次に混合整数二次錐計画問題(MISOCP)の定義について述べる。\\
% 変形した最適化問題の定義
\begin{align}
	\begin{array}{rcl}
		\min & : & \f ^T\x \\
		\text{subject to} & : &||\A_i x +\b_i||_2 \leq \c_i^T\x+\d_i, i = 1,\dots, m \\
		& & \F\x=\g\\
		& & \x_i \in \mathbb{Z}, (i=1,\dots, n)
	\end{array}
\end{align}
ここで、$f \in \Real^n , \A, \b, \c, \d$が定数で$x \in \Real^n$が目的変数である。
% 混合整数の場合の定式化
% 混合整数の場合、内点法などのSOCで使えるアルゴが使用できないことを説明
混合整数二次錐計画問題は決定変数が離散であるため組合せ最適化のアルゴリズムを用いて最適値を求める必要がある。
\subsection{MISOCPとして定式化}\label{sec:Deformation_relax}
% cplexの解法は数値実験章で比較するのみ
% 誰の既存研究の結果を用いているかを必ず明記する。
ここでは、対象問題を解くためのモデルをMISOCPを用いて定式化する。これは、Gambellaらの先行研究の拡張である。\\
まずは定数を定義する。\\
	\begin{description}
	\item[$n$]number of target points
	\item[$q_i$] set of target points coodinates
	\item[$q_{min}$] vector of the minimum of the $q_i$
	\item[$q_{max}$]  vector of the maximum of the $q_i$
	\item[$V_v$] vehicle speed
	\item[$V_c$] carrier speed
	\item[$a$] vehicle operational range
	\item[$p_o$]coordinates of the starting point of the trajectory
	\item[$p_f$]coordinates of the ending point of the trajectory
\end{description}
次に決定変数を定義する。
	\begin{description}
	\item[$Q_i$] coodinates in the i th target point to be visited
	\item[$w_{ij}$] binary variables taking 1 if target point j is visited in position j
	\item[$p_{to, i}$] coordinates of the takeoff point for the visit of $Q_i$
	\item[$p_{l, i}$] coorinates of the landing point after the visit of $Q_i$
	\item[$t_{i,1}$] time taken by the vehicle from $p_{to, i}$ to reach $Q_i$
	\item[$t_{i,2}$] time taken by the vehicle from$Q_i$to reach $p_{l, i}$
	\item[$t_i$] time taken by the carrier from $p_{to, i}$  to reach $p_{l, i}$
	\item[$T_1$] time take by the carrier from $p_o$to reach  $p_{to, 1}$
	\item[$T_i$] time take by the carrier from $p_{l, i-1}$to reach  $p_{to, i}$
	\item[$T_{n+1}$] time take by the carrier from $p_{l,n}$to reach  $p_{f}$
	%TODO: uの定義
\end{description}
 MISOCPモデルを定義する。\\
 \begin{align}
 	\begin{array}{rcl}
 		\min & : & \sum_{i=1}^{n}t_i+\sum_{i=1}^{n+1}T_i\\
 		\text{subject to} & : &\| \A_i x +\b_i\|_2 \leq \c_i^T\x+\d_i, i = 1,\dots, m \\
 		& & \F\x=\g\\
 		& & \x_i \in \mathbb{Z}, (i=1,\dots, n)
 	\end{array}
 \end{align}

\section{提案手法}\label{sec:SimulatedAnnealing}
\subsection{焼きなまし法の説明}

焼きなまし法(Simulated Annealing)とは、大域的最適解を求めるためのメタヒューリスティクスの一種である。 局所的最適解を避けるために、目的関数値が一時的に悪くなるような状態へも遷移するという特徴がある。演算を繰り返すごとに値の変化量が小さくなっていくため、最終的に一つの値に収束する。\\
最小化問題に対する焼きなまし法の疑似アルゴリズムを示す。\\
	\begin{algorithmic}
		\STATE 初期状態を一つとり、最良状態とする。その時のスコアを最良スコアとする。
		\STATE イテレーション数$k = 0$をとる。最大イテレーション数$k_{max}$をとる
		\WHILE{$k<k_{max}$}
		% 	\WHILE{$N \neq 0$}
		\STATE 現在の温度を求める。
		\STATE 新しい状態を近傍関数から得る。
		\STATE 新しい状態のスコアを得る。
		\STATE 現在のスコアと温度をもとに遷移確率を求める。
		\IF{new score < best score}
			\STATE 最良状態、最良スコアにそれぞれ現在の状態とスコアを代入する。
		\ENDIF
		\IF{new score> best score and random<prob}
		\STATE state=next state, score = next score
		\ENDIF
		\ENDWHILE
	\end{algorithmic}
\subsection{提案手法}
% ヒューリスティックを強調した章の名前にしてもいいかも
% 問題を２ステップに分けて考える。辿る順番を求めるパートと、位置を決めるパート
% 辿る順番を決めるのにSAを用いる
% 辿る順番は組合せ最適化問題であり、選び方が途方もなくあるため全部見るのは困難
%　よってこのパートはヒューリスティックを用いて克服する
% 初期回の生成を緩和問題をソルバーで解くことにより効率化できる旨も記す。
対象とする問題は、目的地を辿る順番を決める問題と順番が与えられた際にドローンの発着場所を決める問題の二つに分割することができる。前者は組合せ最適化問題であり、ソルバーで解くのが困難であるため焼きなまし法を用いる。後者はSOCPとして定式化することができ、ソルバーで求解する。\\
以下に提案手法のアルゴリズムの全体を示す。\\
	\begin{algorithmic}
	\STATE 初期状態を一つとり、最良状態とする。その時のスコアを最良スコアとする。
	\STATE イテレーション数$k = 0$をとる。最大イテレーション数$k_{max}$をとる
	\WHILE{$k<k_{max}$}
	% 	\WHILE{$N \neq 0$}
	\STATE 現在の温度を求める。
	\STATE 新しい状態を近傍関数から得る。
	\STATE 新しい状態のスコアを得る。
	\STATE 現在のスコアと温度をもとに遷移確率を求める。
	\IF{new score < best score}
	\STATE 最良状態、最良スコアにそれぞれ現在の状態とスコアを代入する。
	\ENDIF
	\IF{new score> best score and random<prob}
	\STATE state=next state, score = next score
	\ENDIF
	\ENDWHILE
\end{algorithmic}
\section{数値実験}\label{sec:Numerical_Experience}

\subsection{定数の設定}\label{sec:Deformation_to_SDPT3solver}


\subsection{初期点とパラメータの設定}\label{sec:parameter_settings}



\subsection{テスト問題の生成方法}\label{sec:Problem_Generation}


\subsection{実験結果}\label{sec:Numerical_Result}

\subsubsection{計算時間と精度の評価}\label{sec:Evaluation_CPUtime_and_accuracy}


\section{結論}\label{sec:Conclusion}

\clearpage
\section*{謝辞}\label{sec:Acknowledgement}


\clearpage
\begin{small}
\bibliography{soturon.bib}
\end{small}


\end{document}
